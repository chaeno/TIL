# gRPC 시작에서 운영까지
## 1장 gRPC 소개
- 최신 소프트웨어 애플리케이션은 네트워크 상의 분산 애플리케이션으로 구성되어 애플리케이션 간의 연결성이 중요해졌다.
- 마이크로서비스의 세분화로 프로세스 간 통신 기술의 중요도가 높아졌다.
- 프로세스간 통신은 크게 동기식 1) 요청-응답 스타일과 2) 비동기적 이벤트 기반의 스타일로 구분된다.
- 요청-응답 스타일의 통신을 구축할 때 주로 쓰이는 RESTful 서비스는 부피가 크고 비효율적이며 에러가 쉽게 발생한다.
- RESTful 보다 더 효율적이고 확장성이 높은 느슨하게 결합된 프로세스 간 통신 기술이 요구되었고 이는 gRPC가 등장한 배경이다.

### gRPC
- gRPC는 로컬 함수를 호출하는 것만큼 쉽게 분산된 이기종 애플리케이션을 연결, 호출, 운영, 디버깅할 수 있는 프로세스간 통신이다.
- gRPC 개발 시 가장 먼저 해야하는 일은 IDL(Interface Definition Language)를 정의하는 일이다.
- IDL을 통해 서버 스켈레톤과 클라이언트 스텁 코드를 생성하여 낮은 수준의 통신을 추상화한다.
#### 서비스 정의
- gRPC는 프로토콜 버퍼를 IDL로 사용해서 서비스 인터페이스를 정의한다.
- 서비스는 원격으로 호출될 수 있는 메서드의 모음이며 입력 파라미터와 반환 타입을 가지고 있다.
- 입력과 출력 파라미터는 사용자 정의 타입이거나 프로토콜 버퍼의 이미 알려진 타입이다.
#### gRPC 서버
- 프로토콜 버퍼 컴파일러인 protoc를 사용해 서버 측이나 클라이언트 측 코드를 생성할 수 있다.
- 프로토콜 버퍼용 gRPC 플러그인을 사용하면 데이터 지정, 직렬화, 데이터 취득의 일반 프로토콜 버퍼 코드도 생성할 수 있다.
- 서버는 서비스 정의를 구현하고 각 클라이언트 요청을 처리하기 위해 아래의 작업이 필요하다.
  - 상위 서비스 클래스를 오버라이드하여 생성된 서버 스켈레톤의 서비스 로직을 구현한다.
  - gRPC 서버를 실행해 클라이언트 요청을 수신하고 응답한다.
#### gRPC 클라이언트
- 서비스 정의를 사용해 클라이언트 스텁을 생성한다.
- 클라이언트 코드에서 메서드들의 호출을 네트워크상 원격 함수 호출로 변환한다.
- gRPC 서비스 정의는 언어에 구애 받지 않기 때문에 서드파티를 통해 다양한 언어의 클라이언트와 서버를 구현할 수 있다.
#### 클라이언트-서버 메세지 흐름
- 전송 프로토콜은 양방향 메세징을 지원하는 고성능 바이너리 프로토콜인 HTTP/2를 사용한다.
- 클라이언트의 gRPC 라이브러리는 프로토콜 버퍼 형식으로 마샬링하고 서버는 요청을 언마샬링한다.

### 프로세스 간 통신의 역사
- 프로세스간 통신 기술과 gRPC를 비교
#### 기존 RPC
- 기존 CORBA, 자바 RMI 등은 상호운용성을 저해하는 TCP로 구축되고 규격이 과장되어 매우 복잡하다.
#### SOAP
- **S**imple **O**bject **A**ccess **P**rotocal
- XML 기반의 구조화된 데이터 교환용 표준 통신 기술이고 HTTP와 같은 프로토콜을 통해 통신한다.
- 규격과 메세지 포맷의 복잡성 때문에 분산 애플리케이션 구축의 민첩성을 저해한다.
- 기존 분산 애플리케이션 대부분이 이제 SOAP 대신 REST 아키텍쳐 스타일을 사용한다.
#### REST
- **RE**presentational **S**tate **T**ransfer
- 분산된 애플리케이션을 고유한 식별자(URL)로 액세스 할 수 있는 리소스 모음으로 모델링하는 자원 지향 아키텍쳐 기반이다.
- HTTP와 JSON등의 포맷을 사용한 REST 아키텍처 스타일은 표준처럼 사용되었다.
- 마이크로서비스가 많아지고 네트워크 상호작용의 확산으로 RESTful 서비스는 최신 요구 사항을 충족하지 못했다.
  - 비효율적 텍스트 기반 메세지 프로토콜
  - 엄격한 타입 점검 부족
  - REST 아키텍쳐 스타일 강제의 어려움
#### gRPC의 시작
#### 왜 gRPC인가?
#### 다른 프로토콜과의 비교: 그래프QL과 쓰리프트

### gRPC 실사례
#### 넷플릭스
#### etcd
#### 드롭박스

### 요약


## 2장 gRPC 시작

### 서비스 정의 작성
#### 메세지 정의
#### 서비스 정의

### 구현
#### 서비스 개발
#### gRPC 클라이언트 개발

### 빌드와 실행
#### Go 서버 빌드
#### Go 클라이언트 빌드
#### Go 서버와 클라이언트 실행
#### 자바 서버 빌드
#### 자바 클라이언트 빌드
#### 자바 서버와 클라이언트 실행

### 요약


## 3장 gRPC 통신 패턴

### 단순 RPC(단일 RPC)
### 서버 스트리밍 RPC
### 클라이언트 스트리밍 RPC
### 양방향 스트리밍 RPC
### 마이크로서비스 통신을 위한 gRPC
### 요약


## 4장 gRPC: 동작 원리

### RPC 흐름

### 프로토콜 버퍼를 사용한 메세지 인코딩
#### 인코딩 기술

### 길이-접두사 지정 메세지 프레이밍

### HTTP/2를 통한 gRPC
#### 요청 메시지
#### 응답 메시지
#### gRPC 통신 패턴에서의 메세지 흐름 이해

### gRPC 구현 아키텍처

### 요약


## 5장 gRPC: 고급 기능

### 인터셉터
#### 서버 측 인터셉터
#### 클라이언트 측 인터셉터

### 데드라인

### 취소 처리

### 에러 처리

### 멀티플렉싱

### 메타데이터
#### 메타데이터 생성과 조회
#### 메타데이터 전송과 수신: 클라이언트 측
#### 메타데이터 전송과 수신: 서버 측
#### 네임 리졸버

### 로드밸런싱
#### 로드밸런서 프록시
#### 클라이언트 측 로드밸런싱
#### 압축

### 요약


## 6장 보안 적용 gRPC

### TLS를 사용한 gRPC 채널 인증
#### 단방향 보안 연결 활성화
#### mTLS 보안 연결 활성화

### gRPC 호출 인증
#### 베이직 인증 사용
#### OAuth 2.0 사용
#### JWT 사용
#### 구글 토큰 기반 인증 사용

### 요약


## 7장 서비스 수전 gRPC 실행

### gRPC 애플리케이션 테스트
#### gRPC 서버 테스트
#### gRPC 클라이언트 테스트
#### 부하 테스트
#### 지속적인 통합

### 배포
#### 도커로의 배포
#### 쿠버네티스로의 배포

### 관찰 가능성
#### 메트릭
#### 로그
#### 추적

### 디버깅과 문제 해결
#### 추가 로깅 활성화

### 요약


## 8장 gRPC 생태계

### gRPC 게이트웨이

### gRPC를 위한 HTTP/JSON 트랜스코딩

### gRPC 서버 리플렉션 프로토콜

### gRPC 미들웨어

### 상태 확인 프로토콜

### gRPC 상태 프로브

### 다른 생태계 프로젝트

### 요약