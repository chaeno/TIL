# gRPC 시작에서 운영까지
## 1장 gRPC 소개
- 최신 소프트웨어 애플리케이션은 네트워크 상의 분산 애플리케이션으로 구성되어 애플리케이션 간의 연결성이 중요해졌다.
- 마이크로서비스의 세분화로 프로세스 간 통신 기술의 중요도가 높아졌다.
- 프로세스간 통신은 크게 동기식 1) 요청-응답 스타일과 2) 비동기적 이벤트 기반의 스타일로 구분된다.
- 요청-응답 스타일의 통신을 구축할 때 주로 쓰이는 RESTful 서비스는 부피가 크고 비효율적이며 에러가 쉽게 발생한다.
- RESTful 보다 더 효율적이고 확장성이 높은 느슨하게 결합된 프로세스 간 통신 기술이 요구되었고 이는 gRPC가 등장한 배경이다.

### gRPC
- gRPC는 로컬 함수를 호출하는 것만큼 쉽게 분산된 이기종 애플리케이션을 연결, 호출, 운영, 디버깅할 수 있는 프로세스간 통신이다.
- gRPC 개발 시 가장 먼저 해야하는 일은 IDL(Interface Definition Language)를 정의하는 일이다.
- IDL을 통해 서버 스켈레톤과 클라이언트 스텁 코드를 생성하여 낮은 수준의 통신을 추상화한다.
#### 서비스 정의
- gRPC는 프로토콜 버퍼를 IDL로 사용해서 서비스 인터페이스를 정의한다.
- 서비스는 원격으로 호출될 수 있는 메서드의 모음이며 입력 파라미터와 반환 타입을 가지고 있다.
- 입력과 출력 파라미터는 사용자 정의 타입이거나 프로토콜 버퍼의 이미 알려진 타입이다.
#### gRPC 서버
- 프로토콜 버퍼 컴파일러인 protoc를 사용해 서버 측이나 클라이언트 측 코드를 생성할 수 있다.
- 프로토콜 버퍼용 gRPC 플러그인을 사용하면 데이터 지정, 직렬화, 데이터 취득의 일반 프로토콜 버퍼 코드도 생성할 수 있다.
- 서버는 서비스 정의를 구현하고 각 클라이언트 요청을 처리하기 위해 아래의 작업이 필요하다.
  - 상위 서비스 클래스를 오버라이드하여 생성된 서버 스켈레톤의 서비스 로직을 구현한다.
  - gRPC 서버를 실행해 클라이언트 요청을 수신하고 응답한다.
#### gRPC 클라이언트
- 서비스 정의를 사용해 클라이언트 스텁을 생성한다.
- 클라이언트 코드에서 메서드들의 호출을 네트워크상 원격 함수 호출로 변환한다.
- gRPC 서비스 정의는 언어에 구애 받지 않기 때문에 서드파티를 통해 다양한 언어의 클라이언트와 서버를 구현할 수 있다.
#### 클라이언트-서버 메세지 흐름
- 전송 프로토콜은 양방향 메세징을 지원하는 고성능 바이너리 프로토콜인 HTTP/2를 사용한다.
- 클라이언트의 gRPC 라이브러리는 프로토콜 버퍼 형식으로 마샬링하고 서버는 요청을 언마샬링한다.

### 프로세스 간 통신의 역사
- 프로세스간 통신 기술과 gRPC를 비교
#### 기존 RPC
- 기존 CORBA, 자바 RMI 등은 상호운용성을 저해하는 TCP로 구축되고 규격이 과장되어 매우 복잡하다.
#### SOAP
- **S**imple **O**bject **A**ccess **P**rotocal
- XML 기반의 구조화된 데이터 교환용 표준 통신 기술이고 HTTP와 같은 프로토콜을 통해 통신한다.
- 규격과 메세지 포맷의 복잡성 때문에 분산 애플리케이션 구축의 민첩성을 저해한다.
- 기존 분산 애플리케이션 대부분이 이제 SOAP 대신 REST 아키텍쳐 스타일을 사용한다.
#### REST
- **RE**presentational **S**tate **T**ransfer
- 분산된 애플리케이션을 고유한 식별자(URL)로 액세스 할 수 있는 리소스 모음으로 모델링하는 자원 지향 아키텍쳐 기반이다.
- HTTP와 JSON등의 포맷을 사용한 REST 아키텍처 스타일은 표준처럼 사용되었다.
- 마이크로서비스가 많아지고 네트워크 상호작용의 확산으로 RESTful 서비스는 최신 요구 사항을 충족하지 못했다.
  - 비효율적 텍스트 기반 메세지 프로토콜
  - 엄격한 타입 점검 부족
  - REST 아키텍쳐 스타일 강제의 어려움
#### gRPC의 시작
- 구글의 스터비(Stubby) 범용 RPC 프레임워크는 내부 인프라 종속적이여서 표준화되지 못했다.
- 2015년도에 오픈소스 RPC 프레임워크로 gRPC를 출시했다.
#### 왜 gRPC인가?
- gRPC는 기존 프로세스 간 통신 기술의 대부분의 단점을 극복할 수 있다.
  - gRPC의 장점
    - 프로세스 간 통신 효율성
    - 간단 명확한 서비스 인터페이스와 스키마
    - 엄격한 타입 점검 형식
    - 폴리글랏
    - 이중 스트리밍
    - 유용한 내장 기능 지원
    - 클라우드 네이티브 생태계와 통합
    - 성숙하고 널리 채택됨
  - gRPC의 단점
    - 외부 서비스 부적합
    - 서비스 정의의 급격한 변경에 따른 개발 프로세스 복잡성
    - 상대적으로 작은 생태계
#### 다른 프로토콜과의 비교: 그래프QL과 쓰리프트
- 아파치 쓰리프트
  - 페이스북에서 개발돼 나중에 아파치 재단으로 기증되었다.
  - gRPC와 거의 유사하나 생태계 구축에서 gRPC가 우세하다.
- 그래프QL
  - 페이스북에서 개발하고 공개 기술로 표준화
  - API용 쿼리 언어와 기존 데이터에 대한 쿼리 수행용 런타임이다.
  - 클라이언트가 원하는 데이터, 원하는 방식, 원하는 형식을 결정할 수 있다.
  - 소비자에게 직접 노출되는 외부 서비스나 API에 더 적합 

### gRPC 실사례
#### 넷플릭스
- 내부 RPC 프레임워크를 개발하려다 접고 gRPC를 채택했다.
- 넷플릭스 플랫폼의 전반적인 지연 시간이 단축되고 개발자 생산성이 높아졌다.
#### etcd
- 분산 시스템에서 중요한 데이터를 위한 신회할 수 있는 키-값 저장소이다.
- gRPC 사용자용 API를 사용해 gRPC의 모든 기능을 활용한다.
#### 드롭박스
- 초기에는 여러 프레임워크를 사용하다 gRPC로 전환했다.
- gRPC 기반 RPC 프레임워크인 커리어(Courier)를 만들었고 이는 기존 인프라와 gRPC를 통합하는 프로젝트이다.
### 요약
- 최신 소프트웨어에서 프로세스간 통신 기술은 가장 중요하다.
- gRPC는 확장 가능하고 느슨하게 결합된 타입 안전 솔루션이다.


## 2장 gRPC 시작

### 서비스 정의 작성
- 가장 먼저 해야할 일은 서비스 인터페이스를 정의하는 것이다.
- 원격 메서드와 메세지 타입을 정의한다.
#### 메세지 정의
- 메세지는 클라이언트와 서비스 간에 교환되는 데이터 구조이다.
#### 서비스 정의
- 클라이언트에 제공되는 원격 메서드의 모임이다.
- 원격 메서드는 각각 하나의 입력/반환 파라미터를 가진다.
- 여러 값을 전달하기 위해서는 하나의 메시지 타입으로 그룹화한다. 

### 구현
- gRPC 서비스와 클라이언트 소스코드를 생성하기 위해 기존 빌드 도구와 통합하는 것이 더 쉽다.
#### 서비스 개발
- 코드 생성단계로 얻어진 인터페이스를 구현한다.
#### gRPC 클라이언트 개발
- 서비스 정의에서 클라이언트 스텁을 생성하고 원격 메서드를 호출한다.

### 요약
- 서비스 인터페이스를 정의한다.
- 선택한 프로그래밍 언어로 서버/클라이언트 코드를 생성한다.
- 서버는 원격 메서드의 로직을 구현하고 서비스를 바인딩하는 gRPC 서버를 실행한다.
- 클라이언트는 원격 gRPC 서버에 연결하고 원격 메서드를 호출한다.


## 3장 gRPC 통신 패턴

### 단순 RPC(단일 RPC)
- 단일 요청을 서버로 보내고 단일 응답을 받는다.
- 
### 서버 스트리밍 RPC
### 클라이언트 스트리밍 RPC
### 양방향 스트리밍 RPC
### 마이크로서비스 통신을 위한 gRPC
### 요약


## 4장 gRPC: 동작 원리

### RPC 흐름

### 프로토콜 버퍼를 사용한 메세지 인코딩
#### 인코딩 기술

### 길이-접두사 지정 메세지 프레이밍

### HTTP/2를 통한 gRPC
#### 요청 메시지
#### 응답 메시지
#### gRPC 통신 패턴에서의 메세지 흐름 이해

### gRPC 구현 아키텍처

### 요약


## 5장 gRPC: 고급 기능

### 인터셉터
#### 서버 측 인터셉터
#### 클라이언트 측 인터셉터

### 데드라인

### 취소 처리

### 에러 처리

### 멀티플렉싱

### 메타데이터
#### 메타데이터 생성과 조회
#### 메타데이터 전송과 수신: 클라이언트 측
#### 메타데이터 전송과 수신: 서버 측
#### 네임 리졸버

### 로드밸런싱
#### 로드밸런서 프록시
#### 클라이언트 측 로드밸런싱
#### 압축

### 요약


## 6장 보안 적용 gRPC

### TLS를 사용한 gRPC 채널 인증
#### 단방향 보안 연결 활성화
#### mTLS 보안 연결 활성화

### gRPC 호출 인증
#### 베이직 인증 사용
#### OAuth 2.0 사용
#### JWT 사용
#### 구글 토큰 기반 인증 사용

### 요약


## 7장 서비스 수전 gRPC 실행

### gRPC 애플리케이션 테스트
#### gRPC 서버 테스트
#### gRPC 클라이언트 테스트
#### 부하 테스트
#### 지속적인 통합

### 배포
#### 도커로의 배포
#### 쿠버네티스로의 배포

### 관찰 가능성
#### 메트릭
#### 로그
#### 추적

### 디버깅과 문제 해결
#### 추가 로깅 활성화

### 요약


## 8장 gRPC 생태계

### gRPC 게이트웨이

### gRPC를 위한 HTTP/JSON 트랜스코딩

### gRPC 서버 리플렉션 프로토콜

### gRPC 미들웨어

### 상태 확인 프로토콜

### gRPC 상태 프로브

### 다른 생태계 프로젝트

### 요약