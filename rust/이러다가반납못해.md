# 러스트 프로그래밍 공식 가이드 반납 프로젝트

## 01 배경
러스트 책을 회사 비용으로 구매하고 대여한지 1년이 넘었다.  
지금 이걸 공부할 때가 아니라는걸 알지만 지금 안하면 평생 안할 각이다.  
최대한 대충 1회독을 목표로 반납 프로젝트를 시작한다.

근데 왜 **갑분러**인지 생각해봤다.
- **나는 왜 러스트를 배우고 싶은가?**  
  1. 러스트는 시스템 프로그래밍을 위한 언어이다. 나는 회사에서 임베디드 개발자로 시작해서 지금은 백엔드 개발자로 일하고 있지만, 시작은 대학원에서 배운 시스템 프로그래밍이였다. 그래서 러스트가 나에겐 흥미로운 언어이다.
  2. 러스트의 프로그래밍 범위는 매우 넓다. 러스트의 시작인 브라우저 랜더링 엔진에서 부터 운영체제, 웹서버, 임베디드, 웹 어셈블리를 모두 커버하므로 내가 해볼 수 있는 분야의 저변이 확대될 수 있다고 기대한다.
  3. 러스트에서 주의깊게 다뤄야하는 프로그래밍 스킬들이 다른 언어로 개발할 때 도움이 될 것이라 생각한다. 저수준의 메모리 관리, 데이터 표현, 동시성 등은 어렵지만 프로그래밍 실력 향상에 좋은 주제들이다.
  4. 최종적인 목표는 라즈베리 파이에 러스트로 토이 프로젝트를 해보는 것이다. 생각해보니 회사일에는 역시나 도움이 안되겠다만, 내가 재밌는거 하나쯤은 괜찮지 않을까.


그럼 매일 조금씩 공부하고 기록을 남기자.

## DAY 01
- rust 설치
- 국룰 hello world 출력하기
```
fn main() {
    println!("Hello, world!");
}
```
- rust discord 채널 가입

## DAY 02
- C2 숫자 맞히기 게임의 구현

## DAY 03
- 자료형
- 조건문
- 반복문
- 피보나치 숫자 구하기

# DAY 04
- 소유권
  - rust가 다른 언어와 가장 큰 차이는 여기에 있다. 사용자에게 직접 힙 메모리에 대한 관리를 맡기지도 않고 GC를 사용하지도 않는다. 힙 메모리에 할당된 변수가 scope에서 사라질 때 소유권을 가진 경우는 반드시 메모리를 Drop한다. 복잡할 수 있는 규칙들이 있지만 하나의 변수를 코드의 여러 곳에서 사용 시 의도치 않은 변수의 변화를 금지한다라는 대전제를 생각해보면 대부분 합리적인 방식을 취하고 있으므로 이해하는데 어려움은 없다.
- 대여
- 슬라이스

# DAY 05
- 구조체
- 메서드
- 연관함수
  - go와는 다르게 연관함수라는 개념이 존재한다. 구조체 인스턴스가 없는 상황에서 구조체에 적용할 수 있는 기능을 구분짓는데 활용될 수 있다. 예제에서는 인스턴스 생성 함수로 활용된다.

# DAY 06
- 열거자
- Option<T>
  - rust에는 null 값이 존재하지 않는다. Option<T> 열거자를 통해 None 값이 null을 대체하여 사용되고 Some<T>으로 어떠한 변수 값이든 저장할 수 있다. Option<T>로 변환되지 않은 일반 변수는 null 참조에 대한 에러에 자유로울 수 있다.
  - null의 창시자인 토니 호어(tony Hoare)는 2009년 '널 참조: 십억짜리 실수(Null reference: The Billion Dollar Mistake)'라는 강연에서 null 값은 내가 저지른 엄청난 실수이고 단지 더 쉽게 구현할 수 있었기 때문에 사용했다. 이로 인해 십억 달러의 가치에 맞먹는 고통을 유발했다고 말했다. 러스트에서 null을 사용하지 않는 이유 (널 값을 널 값이 아닌 것처럼 사용할 때 에러가 발생) 에 대한 단락에 포함된 내용이다. 개발할 때도 항상 개발이 쉬운 방향으로의 선택을 의심해야하는 이유로 들어도 좋을 사례라고 생각이 된다.
- match
  - if / switch 문과 비슷하다고 생각할 수 도 있지만 패턴 처리가 다양하고 바인딩, 컴파일러의 모든 케이스에 대한 검사 등의 장점을 가지고 있다.
- if let
  - match는 모든 경우의 수를 다뤄야하고 다루지 못한 경우는 모두 자리지정자 _ 를 통해 처리해야만 한다. match를 사용하는 것이 코드를 장황하게 만드는 경우 syntax sugar로 if let 문법을 사용할 수 있다. 이는 코드를 더 간편하게 사용할 수 있도록 도와준다.

# DAY 07
- 패키지
- 크레이트
- 모듈

# DAY 08
- 벡터
- 문자열
- 해시 맵

# DAY 09
- 에러 처리
- panic! 매크로
- Result 열거자

# DAT 10
- 제네릭
  - rust에서 제네릭을 사용하면 성능이 느려질까? 정답은 느려지지 않는다. 이유는 rust가 컴파일 시점에 제네릭을 사용하는 코드를 단일화(Monomorphzation) 때문이다. 단일화란, 컴파일 시점에 제네릭 코드를 실제로 사용하는 구체화된 타입으로 변환하는 과정이다.

# DAY 11
- 트레이트
  - 트레이트는 공유 가능한 행위를 정의하는 방법으로 다른 언어에서 인터페이스라고 불리는 것과 흡사하지만 차이점도 존재한다. 트레이트 경계는 제너릭 사용 시 특정 기능 수행이 가능한 타입만 받을 수 있도록 제약을 걸어줄 수 있다.

# DAY 12
- 수명
  - rust에서 가장 새로운 특징이다. 참조 유효성을 컴파일 단계에서 판단하기 위해 존재한다. 매번 수명 애노테이션을 달아줘야하는 번거로움을 막기 위해 생략할 수 있는 규칙들이 몇 가지 있고 이는 최초의 rust에서는 허용하지 않았던 내용이다.

# DAY 13
- 단위 테스트
- 통합 테스트

# DAY 14
- I/O 프로젝트: grep 기능 cli 기본 구현 
  - 파일을 읽어 query한 문자열을 포함하고 있는 line을 출력하는 cli를 구현
  - main.rs는 테스트가 필요하지 않을 정도로 짧고 명확한 코드만을 남기고 lib.rs에서 로직을 구현한다.
  - lib.rs는 단위 테스트를 구현할 수 있고 TDD 방식의 구현이 가능하다.

# DAY 15
- I/O 프로젝트 추가 구현
  - 환경 변수 다루기
  - stderr 출력

# DAY 16
- 클로저
  - 클로저는 자신의 주변에서 값을 캡쳐한다. 매개변수로 넘기지 않아도 클로저가 생성된 context에 존재하는 변수들에 대해 접근할 수 있다. 이 범위를 클로저의 환경(environment)이라 한다. 기본적으로는 불변으로 대여하나 move 키워드를 통해 소유권을 완전히 가져올 수 있다. 이럴 경우 해당 변수는 클로저 수행 이후 접근할 수 없게 된다. 트레이트 경계를 통해서 Fn(불변으로 대여), FnOnce(소유권을 클로저가 1번만 가져옴), FnMut(가변으로 대여)를 구분하여 사용할 수 있다. 클로저는 함수에 비해 주변 환경을 캡쳐하는 오버헤드가 있다. 그러므로 주변의 값을 캡쳐할 필요가 없을 경우에는 함수를 활용하는 것을 추천한다.

# DAY 17
- 반복자
- 클로저와 반복자를 통해 I/O 프로젝트 개선
  - 반복자는 rust의 무비용 추상화(zero-cost abstractions) 기능 중 하나이다. 즉 사용자가 직접 루프를 작성하여 실행시키는 코드나 반복자를 사용하는 코드나 어셈블리 코드는 동일하다는 뜻이다. 컴파일러가 반복자의 동작을 파악하여 동일한 형태의 어셈블리 코드를 생성하므로 성능의 감소는 전혀 없고 코드는 더 간소화되는 장점을 가진다.

# DAY 18
- 카고
  - cargo에 대한 추가 기능과 내가 만든 crate를 crate.io에 등록하는 방법, 그리고 workspace를 통해 여러 crate를 통합하여 사용하는 방법

# DAY 19
- Box<T>는 T에 해당하는 데이터 타입을 힙에 할당하여 그 주소를 저장한다. 주소 값은 알려진 크기이므로 컴파일 타임에 크기를 정할 수 있고 스택에 저장 가능하다. 컴파일 타임에 크기를 알 수 없는 재귀적 타입을 사용할 때 Box<T>를 사용할 수 있다.

# DAY 20
- Defer 트레이트
  - 스마트 포인터와 참조는 동일하게 다룰 수 있다.

# DAY 21
- Drop trait
- 참조 카운터 스마트 포인터 Rc<T> (reference counting) only 단일 스레드 환경에서만 사용가능
- RefCell<T> 내부 가변성 패턴
  - 컴파일러가 보장하지 않는 가변/불변 대여를 가능하게 하는 타입
  - 빌드 시 에러는 안나지만 규칙을 어길 경우 런타임에 에러가 발생한다.
  - 이게 왜 필요하나 싶겠지만, 테스트 코드를 작성할 때 실제 trait에 구현해야하는 함수는 unmutable한데 테스트 결과를 스스로 저장하고 있어야하는 경우 일시적으로 borrow_mut()로 가변 참조를 가져와 값을 변경시켜 유용하게 사용할 수 있다. 

# DAY 22
- Rc<T>와 RefCell<T>를 조합해서 가변 데이터에 다중 소유권 적용하기
- 순환참조로 인한 메모리 누수와 순환 참조를 방지하기 위한 Weak<T> 활용

# DAY 23
- 자신 있는 동시성

# DAY 24
- 객체지향 프로그래체
  - 트레이트 객체

# DAY 25
- 객체지향 프로그래밍
  - 객체지향 디자인 패턴 구현 (상태 패턴)

# DAY 26
- 패턴과 매칭-1

# DAY 27
- 패턴과 매칭-2

# DAY 28
- 안전하지 않은 러스트

# DAY 29
- 고급 트레이트 
